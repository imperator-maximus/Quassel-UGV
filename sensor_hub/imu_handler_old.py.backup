#!/usr/bin/env python3
"""
ICM-42688-P IMU Handler
6-DoF Inertial Measurement Unit (Accelerometer + Gyroscope)
I2C Communication on Raspberry Pi Zero 2W

Features:
- Gyro Bias Kalibrierung
- Accelerometer Offset Kalibrierung
- Roll/Pitch/Yaw Berechnung mit Komplement√§rfilter
- Heading Fusion mit GPS
"""

import smbus2
import struct
import time
import threading
import logging
import math
from typing import Dict, Tuple, Optional

logger = logging.getLogger(__name__)


class ICM42688P:
    """ICM-42688-P IMU Sensor Handler"""
    
    # Register Adressen (ICM-42688-P)
    REG_WHO_AM_I = 0x75          # Device ID (sollte 0x47 sein)

    # === CORRECT REGISTER ADDRESSES (FROM DATASHEET, BANK 0) ===
    # 14-Byte zusammenh√§ngender Block: Temp(2) + Accel(6) + Gyro(6)
    REG_TEMP_DATA1 = 0x1D        # Temperature High Byte (Start des 14-Byte-Blocks)
    REG_TEMP_DATA0 = 0x1E        # Temperature Low Byte
    REG_ACCEL_DATA_X1 = 0x1F     # Accel X High Byte
    REG_ACCEL_DATA_X0 = 0x20     # Accel X Low Byte
    REG_ACCEL_DATA_Y1 = 0x21     # Accel Y High Byte
    REG_ACCEL_DATA_Y0 = 0x22     # Accel Y Low Byte
    REG_ACCEL_DATA_Z1 = 0x23     # Accel Z High Byte
    REG_ACCEL_DATA_Z0 = 0x24     # Accel Z Low Byte
    REG_GYRO_DATA_X1 = 0x25      # Gyro X High Byte
    REG_GYRO_DATA_X0 = 0x26      # Gyro X Low Byte
    REG_GYRO_DATA_Y1 = 0x27      # Gyro Y High Byte
    REG_GYRO_DATA_Y0 = 0x28      # Gyro Y Low Byte
    REG_GYRO_DATA_Z1 = 0x29      # Gyro Z High Byte
    REG_GYRO_DATA_Z0 = 0x2A      # Gyro Z Low Byte (Ende des 14-Byte-Blocks)
    # ==========================================================

    REG_PWR_MGMT0 = 0x4E         # Power Management
    REG_ACCEL_CONFIG0 = 0x50     # Accelerometer Config
    REG_GYRO_CONFIG0 = 0x4F      # Gyroscope Config
    REG_INT_CONFIG = 0x14        # Interrupt Config
    REG_INT_STATUS = 0x19        # Interrupt Status
    REG_SIGNAL_PATH_RESET = 0x4B # Signal Path Reset
    REG_DEVICE_CONFIG = 0x11     # Device Config
    
    # Skalierungsfaktoren (ICM-42688-P bei ¬±2g und ¬±250¬∞/s)
    ACCEL_SCALE_2G = 16384.0     # LSB/g bei ¬±2g
    GYRO_SCALE_250DPS = 131.0    # LSB/(¬∞/s) bei ¬±250¬∞/s
    TEMP_SCALE = 132.48          # LSB/¬∞C (Temperatur-Empfindlichkeit)
    TEMP_OFFSET = 25.0           # Offset bei 0 LSB (Raumtemperatur)
    
    def __init__(self, bus: int = 1, address: int = 0x68, sample_rate: int = 200):
        """
        Initialisiert IMU

        Args:
            bus: I2C Bus Nummer (1 f√ºr Raspberry Pi)
            address: I2C Adresse (0x68 oder 0x69)
            sample_rate: Sample Rate in Hz (100, 200, 500, 1000)
        """
        self.bus_num = bus
        self.address = address
        self.sample_rate = sample_rate
        self.bus = None
        self.running = False
        self.connected = False

        # Sensor-Daten (roh)
        self.accel = {'x': 0.0, 'y': 0.0, 'z': 0.0}  # m/s¬≤
        self.gyro = {'x': 0.0, 'y': 0.0, 'z': 0.0}   # ¬∞/s
        self.temperature = 0.0                         # ¬∞C

        # Kalibrierungs-Daten
        self.gyro_bias = {'x': 0.0, 'y': 0.0, 'z': 0.0}  # ¬∞/s Offset
        self.accel_offset = {'x': 0.0, 'y': 0.0, 'z': 0.0}  # m/s¬≤ Offset
        self.is_calibrated = False

        # Orientierung (Roll/Pitch/Yaw in Grad)
        self.roll = 0.0   # Rotation um X-Achse
        self.pitch = 0.0  # Rotation um Y-Achse
        self.yaw = 0.0    # Rotation um Z-Achse (Heading)

        # Komplement√§rfilter Parameter
        self.alpha = 0.98  # Gewichtung: 0.98 = 98% Gyro, 2% Accel
        self.last_update_time = time.time()

        # GPS Heading Fusion
        self.gps_heading = None  # GPS Heading in Grad (von au√üen gesetzt)
        self.gps_heading_weight = 0.3  # Gewichtung f√ºr GPS Heading

        # Thread f√ºr kontinuierliches Lesen
        self.read_thread = None
        self.lock = threading.Lock()
    
    def connect(self) -> bool:
        """Verbindet sich mit dem Sensor"""
        try:
            self.bus = smbus2.SMBus(self.bus_num)
            logger.info(f"‚úÖ I2C Bus {self.bus_num} ge√∂ffnet")

            # WHO_AM_I Register auslesen
            try:
                device_id = self.bus.read_byte_data(self.address, self.REG_WHO_AM_I)
                logger.info(f"‚úÖ WHO_AM_I gelesen: 0x{device_id:02x}")

                if device_id == 0x47:
                    logger.info(f"‚úÖ ICM-42688-P erkannt")
                else:
                    logger.warning(f"‚ö†Ô∏è  Unerwartete Device ID: 0x{device_id:02x}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è  WHO_AM_I Fehler: {e}")

            # Sensor konfigurieren
            self._configure_sensor()

            self.connected = True
            self.running = True

            # Read-Thread starten
            self.read_thread = threading.Thread(target=self._read_loop, daemon=True)
            self.read_thread.start()

            logger.info(f"‚úÖ IMU verbunden auf I2C Bus {self.bus_num}, Adresse 0x{self.address:02x}")
            return True

        except Exception as e:
            logger.error(f"‚ùå IMU-Verbindung fehlgeschlagen: {e}")
            if self.bus:
                try:
                    self.bus.close()
                except:
                    pass
            return False
    
    def _configure_sensor(self):
        """Konfiguriert den Sensor korrekt"""
        try:
            # 1. Reset Signal Path
            self.bus.write_byte_data(self.address, self.REG_SIGNAL_PATH_RESET, 0x01)
            time.sleep(0.1)
            logger.debug("‚úÖ Signal Path Reset")

            # 2. Power Management: Accel & Gyro im Low Noise Mode
            # 0x0F = Accel LN (11), Gyro LN (11)
            self.bus.write_byte_data(self.address, self.REG_PWR_MGMT0, 0x0F)
            time.sleep(0.1)
            logger.debug("‚úÖ Power Management konfiguriert")

            # 3. ODR (Sample Rate) bestimmen
            # ODR Bits: 1000Hz=0x06, 200Hz=0x07, 100Hz=0x08, 50Hz=0x09
            if self.sample_rate >= 1000:
                odr_bits = 0x06
            elif self.sample_rate >= 200:
                odr_bits = 0x07
            elif self.sample_rate >= 100:
                odr_bits = 0x08
            else:
                odr_bits = 0x09  # 50Hz Standard

            logger.info(f"Setze ODR auf {self.sample_rate}Hz (Register-Bits: 0x{odr_bits:02X})")

            # 4. Accelerometer Config: ¬±2g, ODR
            # FS_SEL = 011 (Bits 7-5) -> ¬±2g
            # ODR = odr_bits (Bits 3-0)
            accel_config = (0b011 << 5) | odr_bits
            self.bus.write_byte_data(self.address, self.REG_ACCEL_CONFIG0, accel_config)
            time.sleep(0.05)
            logger.debug(f"‚úÖ Accelerometer Config: 0x{accel_config:02X}")

            # 5. Gyroscope Config: ¬±250 dps, ODR
            # FS_SEL = 011 (Bits 7-5) -> ¬±250 dps
            # ODR = odr_bits (Bits 3-0)
            gyro_config = (0b011 << 5) | odr_bits
            self.bus.write_byte_data(self.address, self.REG_GYRO_CONFIG0, gyro_config)
            time.sleep(0.05)
            logger.debug(f"‚úÖ Gyroscope Config: 0x{gyro_config:02X}")

            # Warten auf Sensor-Stabilisierung
            time.sleep(0.1)
            logger.info(f"‚úÖ Sensor konfiguriert: ¬±2g, ¬±250dps @ {self.sample_rate}Hz")

        except Exception as e:
            logger.warning(f"‚ö†Ô∏è  Sensor-Konfiguration: {e}")
    
    def _read_loop(self):
        """Liest kontinuierlich Sensor-Daten"""
        while self.running:
            try:
                self._read_sensor_data()
                time.sleep(1.0 / self.sample_rate)
            except Exception as e:
                logger.debug(f"‚ö†Ô∏è  Sensor-Read Fehler: {e}")
                time.sleep(0.01)
    
    def _read_sensor_data(self):
        """Liest Rohdaten vom Sensor aus dem korrekten zusammenh√§ngenden Register-Block"""
        try:
            # 1. Lese ALLE 14 Bytes am St√ºck (Temp + Accel + Gyro)
            # Der Block ist zusammenh√§ngend und startet bei 0x1D (TEMP_DATA1)
            data_block = self.bus.read_i2c_block_data(
                self.address, self.REG_TEMP_DATA1, 14
            )

            if len(data_block) < 14:
                logger.debug(f"‚ö†Ô∏è  Unvollst√§ndige Daten: {len(data_block)} Bytes")
                return

            # 2. Daten entpacken (Big-Endian) - Reihenfolge im Block: Temp(1), Accel(3), Gyro(3)
            # struct format '>hhhhhhh' is correct for 7 x 16-bit signed integers in big-endian
            temp_raw, \
            accel_x_raw, accel_y_raw, accel_z_raw, \
            gyro_x_raw, gyro_y_raw, gyro_z_raw = struct.unpack('>hhhhhhh', bytes(data_block))

            # 3. In physikalische Einheiten konvertieren
            with self.lock:
                # Temperatur: LSB zu ¬∞C
                self.temperature = self.TEMP_OFFSET + (temp_raw / self.TEMP_SCALE)

                # Beschleunigung: LSB zu m/s¬≤ (mit Kalibrierung)
                self.accel['x'] = (accel_x_raw / self.ACCEL_SCALE_2G) * 9.81 - self.accel_offset['x']
                self.accel['y'] = (accel_y_raw / self.ACCEL_SCALE_2G) * 9.81 - self.accel_offset['y']
                self.accel['z'] = (accel_z_raw / self.ACCEL_SCALE_2G) * 9.81 - self.accel_offset['z']

                # Drehrate: LSB zu ¬∞/s (mit Kalibrierung)
                self.gyro['x'] = (gyro_x_raw / self.GYRO_SCALE_250DPS) - self.gyro_bias['x']
                self.gyro['y'] = (gyro_y_raw / self.GYRO_SCALE_250DPS) - self.gyro_bias['y']
                self.gyro['z'] = (gyro_z_raw / self.GYRO_SCALE_250DPS) - self.gyro_bias['z']

                # Roll/Pitch/Yaw berechnen
                self._update_orientation()

        except struct.error as e:
            logger.debug(f"‚ö†Ô∏è  Struct-Fehler beim Entpacken der IMU-Daten: {e}")
        except OSError as e:
            # Log specific OSError for I2C issues
            logger.debug(f"‚ö†Ô∏è  I2C Lese-Fehler (OSError): {e}")
        except Exception as e:
            # Catch other potential exceptions during I2C read or processing
            logger.debug(f"‚ö†Ô∏è  Allgemeiner IMU-Daten-Fehler: {e}")

    def _update_orientation(self):
        """
        Berechnet Roll/Pitch/Yaw mit Komplement√§rfilter
        Muss innerhalb des Locks aufgerufen werden!
        """
        # Zeitdifferenz berechnen
        current_time = time.time()
        dt = current_time - self.last_update_time
        self.last_update_time = current_time

        # Roll und Pitch aus Accelerometer berechnen (in Grad)
        accel_roll = math.atan2(self.accel['y'], self.accel['z']) * 180.0 / math.pi
        accel_pitch = math.atan2(-self.accel['x'],
                                  math.sqrt(self.accel['y']**2 + self.accel['z']**2)) * 180.0 / math.pi

        # Gyro-Integration (in Grad)
        gyro_roll = self.roll + self.gyro['x'] * dt
        gyro_pitch = self.pitch + self.gyro['y'] * dt
        gyro_yaw = self.yaw + self.gyro['z'] * dt

        # Komplement√§rfilter: 98% Gyro, 2% Accel
        self.roll = self.alpha * gyro_roll + (1.0 - self.alpha) * accel_roll
        self.pitch = self.alpha * gyro_pitch + (1.0 - self.alpha) * accel_pitch

        # Yaw: Nur Gyro-Integration (kein Magnetometer)
        self.yaw = gyro_yaw

        # GPS Heading Fusion (wenn verf√ºgbar)
        if self.gps_heading is not None:
            # Fusioniere IMU Yaw mit GPS Heading
            # GPS Heading hat mehr Gewicht bei langsamer Bewegung
            self.yaw = (1.0 - self.gps_heading_weight) * self.yaw + \
                       self.gps_heading_weight * self.gps_heading

        # Yaw auf 0-360¬∞ normalisieren
        self.yaw = self.yaw % 360.0
        if self.yaw < 0:
            self.yaw += 360.0

    def calibrate(self, samples: int = 1000) -> bool:
        """
        Kalibriert Gyro und Accelerometer
        WICHTIG: IMU muss w√§hrend Kalibrierung STILL liegen!

        Args:
            samples: Anzahl der Samples f√ºr Kalibrierung

        Returns:
            True wenn erfolgreich
        """
        if not self.connected:
            logger.error("‚ùå IMU nicht verbunden - Kalibrierung nicht m√∂glich")
            return False

        logger.info(f"üîß Starte IMU-Kalibrierung mit {samples} Samples...")
        logger.info("‚ö†Ô∏è  WICHTIG: IMU muss STILL liegen!")

        # Akkumulatoren
        gyro_sum = {'x': 0.0, 'y': 0.0, 'z': 0.0}
        accel_sum = {'x': 0.0, 'y': 0.0, 'z': 0.0}

        # Samples sammeln
        for i in range(samples):
            with self.lock:
                # Gyro (sollte 0 sein wenn still)
                gyro_sum['x'] += self.gyro['x']
                gyro_sum['y'] += self.gyro['y']
                gyro_sum['z'] += self.gyro['z']

                # Accel (Z sollte ~9.81 m/s¬≤ sein, X/Y sollten ~0 sein)
                accel_sum['x'] += self.accel['x']
                accel_sum['y'] += self.accel['y']
                accel_sum['z'] += self.accel['z']

            time.sleep(0.01)  # 10ms zwischen Samples

        # Mittelwerte berechnen
        with self.lock:
            self.gyro_bias['x'] = gyro_sum['x'] / samples
            self.gyro_bias['y'] = gyro_sum['y'] / samples
            self.gyro_bias['z'] = gyro_sum['z'] / samples

            self.accel_offset['x'] = accel_sum['x'] / samples
            self.accel_offset['y'] = accel_sum['y'] / samples
            self.accel_offset['z'] = (accel_sum['z'] / samples) - 9.81  # Z sollte 9.81 sein

            self.is_calibrated = True

        logger.info(f"‚úÖ Kalibrierung abgeschlossen!")
        logger.info(f"   Gyro Bias: X={self.gyro_bias['x']:.3f}¬∞/s, "
                   f"Y={self.gyro_bias['y']:.3f}¬∞/s, Z={self.gyro_bias['z']:.3f}¬∞/s")
        logger.info(f"   Accel Offset: X={self.accel_offset['x']:.3f}m/s¬≤, "
                   f"Y={self.accel_offset['y']:.3f}m/s¬≤, Z={self.accel_offset['z']:.3f}m/s¬≤")

        return True

    def set_gps_heading(self, heading: Optional[float]):
        """
        Setzt GPS Heading f√ºr Fusion mit IMU Yaw

        Args:
            heading: GPS Heading in Grad (0-360) oder None
        """
        with self.lock:
            self.gps_heading = heading
    
    def get_data(self) -> Dict:
        """Gibt aktuelle Sensor-Daten zur√ºck"""
        with self.lock:
            return {
                'accel': self.accel.copy(),
                'gyro': self.gyro.copy(),
                'temperature': self.temperature,
                'roll': self.roll,
                'pitch': self.pitch,
                'yaw': self.yaw,
                'heading': self.yaw,  # Alias f√ºr Yaw
                'is_calibrated': self.is_calibrated,
                'timestamp': time.time()
            }

    def get_orientation(self) -> Dict[str, float]:
        """Gibt Roll/Pitch/Yaw in Grad zur√ºck"""
        with self.lock:
            return {
                'roll': self.roll,
                'pitch': self.pitch,
                'yaw': self.yaw,
                'heading': self.yaw
            }

    def get_accel(self) -> Dict[str, float]:
        """Gibt Beschleunigung in m/s¬≤ zur√ºck"""
        with self.lock:
            return self.accel.copy()

    def get_gyro(self) -> Dict[str, float]:
        """Gibt Drehrate in ¬∞/s zur√ºck"""
        with self.lock:
            return self.gyro.copy()

    def get_temperature(self) -> float:
        """Gibt Temperatur in ¬∞C zur√ºck"""
        with self.lock:
            return self.temperature

    def get_heading(self) -> float:
        """Gibt Heading (Yaw) in Grad zur√ºck"""
        with self.lock:
            return self.yaw
    
    def disconnect(self):
        """Trennt Verbindung zum Sensor"""
        self.running = False
        if self.read_thread:
            self.read_thread.join(timeout=1.0)
        if self.bus:
            self.bus.close()
        self.connected = False
        logger.info("‚úÖ IMU getrennt")

